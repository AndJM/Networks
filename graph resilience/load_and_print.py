"""This module contains data loading and visualization functionality."""


# import urllib2
import matplotlib.pyplot as plt
from timeit import default_timer
from tools import *

FILENAME = 'alg_rf7.txt'
URL = "http://storage.googleapis.com/codeskulptor-alg/alg_rf7.txt"


def counts(graph, name='Graph'):
    """Print and return node and edge counts"""
    count_nodes = len(graph)
    count_edges = edge_count(graph)
    print("Created undirected graph {0} with {1} nodes and {2} edges.".format(
                                            name, count_nodes, count_edges))
    return count_nodes, count_edges


def load_graph():
    """Load a graph from file and return a dictionary representation."""
    graph = {}

    def process_lines(datafile):
        for line in datafile:
            if not line.startswith(' '):  # actual file ends with an empty line
                line = line.strip()
                line = line.split(' ')
                yield line

    # graph_file = urllib2.urlopen(URL)
    with open(FILENAME) as graph_file:
        for line in process_lines(graph_file):
            node = int(line[0])
            graph[node] = set([])
            for neighbor in line[1:]:
                graph[node].add(int(neighbor))
    return graph


def avg_degree(nodes, edges):
    return 2.0 * edges / nodes


network_graph = load_graph()
network_nodes, network_edges = counts(network_graph, "'Network'")
avg_deg1 = avg_degree(network_nodes, network_edges)
print("Average degree of a node is", avg_deg1, "\n")

# ratio of edges to total number of edges of a complete graph on the same number of vertices
p = avg_deg1 / (network_nodes - 1)

er_graph = make_er_ugraph(network_nodes, p)
er_nodes, er_edges = counts(er_graph, "'ER'")
avg_deg2 = avg_degree(er_nodes, er_edges)
print("Average degree of a node is", avg_deg2, "\n")

initial_size = 3
upa_graph = upa_algorithm(initial_size, network_nodes)
upa_nodes, upa_edges = counts(upa_graph, "'UPA'")
avg_deg3 = avg_degree(upa_nodes, upa_edges)
print("Average degree of a node is", avg_deg3, "\n")

xvals = range(network_nodes + 1)


def make_plot1():
    """
    Create three line plots for resilience distribution for Network, ER, and
    UPA graphs using a random attack sequence.
    """
    attack_seq1 = random_order(network_graph)

    yvals1 = compute_resilience(network_graph, attack_seq1)
    yvals2 = compute_resilience(er_graph, attack_seq1)
    yvals3 = compute_resilience(upa_graph, attack_seq1)

    plt.plot(xvals, yvals1, '-b', label='Network graph')
    plt.plot(xvals, yvals2, '-g', label='ER graph, p={:2.1f}%'.format(p * 100))
    plt.plot(xvals, yvals3, '-r', label='UPA graph, m={}'.format(initial_size))
    plt.title('Comparison of network resilience \n'
              'for Network, ER and UPA graphs \n in random attacks')
    plt.xlabel('Number of nodes removed')
    plt.ylabel('Size of the largest connected component')
    plt.legend(loc='upper right')
    plt.show()


def make_plot2():
    """
    Create three line plots for resilience distribution for Network, ER, and
    UPA graphs using attack pattern generated by fast_targeted_order.
    """
    attack_seq2 = fast_targeted_order(network_graph)
    attack_seq3 = fast_targeted_order(er_graph)
    attack_seq4 = fast_targeted_order(upa_graph)

    yvals4 = compute_resilience(network_graph, attack_seq2)
    yvals5 = compute_resilience(er_graph, attack_seq3)
    yvals6 = compute_resilience(upa_graph, attack_seq4)

    print("ptwo=",p)
    plt.plot(xvals, yvals4, '-b', label='Network graph')
    plt.plot(xvals, yvals5, '-g', label='ER graph, p={:2.1f}%'.format(p * 100))
    plt.plot(xvals, yvals6, '-r', label='UPA graph, m={}'.format(initial_size))
    plt.title('Comparison of network resilience \n'
              'for Network, ER and UPA graphs \n'
              'targeted attacks by highest degree first')
    plt.xlabel('Number of nodes removed')
    plt.ylabel('Size of the largest connected component')
    plt.legend(loc='upper right')
    plt.show()


def make_plot3():
    """
    Running time comparison of targeted_order and fast_targeted_order
    using UPA graphs.
    """
    initial_size = 5
    xvals = range(10, 1000, 10)
    yvals7 = []
    yvals8 = []

    import gc
    gc.disable()  # to remove the spikes in the plot

    for n in xvals:
        upa_graph = upa_algorithm(initial_size, n)

        start_time = default_timer()
        targeted_order(upa_graph)
        t = default_timer() - start_time
        yvals7.append(t)

        start_time = default_timer()
        fast_targeted_order(upa_graph)
        t = default_timer() - start_time
        yvals8.append(t)

    gc.enable()

    plt.plot(xvals, yvals7, '-b', label='targeted_order')
    plt.plot(xvals, yvals8, '-r', label='fast_targeted_order')
    plt.title('Comparison of targeted_order and fast_targeted_order '
              'running times \n using UPA graphs on desktop Python \n')
    plt.xlabel('Number of nodes')
    plt.ylabel('Time')
    plt.legend(loc='upper left')
    plt.show()


if __name__ == '__main__':
    make_plot1()
    make_plot2()
    make_plot3()
    exit()
